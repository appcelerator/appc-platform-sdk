'use strict';

/**
 * Code generated by Appcelerator Arrow Generator
 *
 * appc-registry-server
 *
 * Copyright (c) 2015 Appcelerator, Inc.
 *
 * WARNING: This is generated code. Any changes will be overwritten
 * if you re-run the generator on this file.
 */

const async = require('async');
const events = require('events');
const fs = require('fs');
const stream = require('stream');
const tty = require('tty');
const urllib = require('url');
const util = require('util');

const querystring = require('querystring');
const request = require('request');

const useColors = tty.isatty(process.stderr);
const debugEnabled = !!(process.env.DEBUG && (process.env.DEBUG.indexOf('arrow:sdk') !== -1 || process.env.DEBUG.indexOf('*') !== -1));

const UserAgent = require('../useragent');

// APIs defined by Arrow API
let APIs = {
	'listComponents': {
		'method': 'GET',
		'path': '/api/component',
		'description': 'API for fetching all the components'
	},
	'plugins': {
		'method': 'GET',
		'path': '/api/plugin',
		'description': 'API for listing plugins',
		'parameters': {
			'type': {
				'description': 'the type of component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'subtype': {
				'description': 'the subtype of the plugin',
				'optional': false,
				'name': 'subtype',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'subtype'
		]
	},
	'publish': {
		'method': 'POST',
		'path': '/api/publish',
		'description': 'API for publishing a component',
		'parameters': {
			'file': {
				'description': 'file to publish',
				'type': 'body',
				'optional': false,
				'name': 'file'
			},
			'package.json': {
				'description': 'contents of the package.json',
				'type': 'body',
				'optional': false,
				'name': 'package.json'
			},
			'appc.json': {
				'description': 'contents of the appc.json',
				'type': 'body',
				'optional': false,
				'name': 'appc.json'
			},
			'assets.tgz': {
				'description': 'contents of the assets.tgz',
				'type': 'body',
				'optional': true,
				'name': 'assets.tgz'
			},
			'assets': {
				'description': 'contents of the assets configuration',
				'type': 'body',
				'optional': true,
				'name': 'assets'
			},
			'shasum': {
				'description': 'the component sha1',
				'type': 'body',
				'optional': false,
				'name': 'shasum'
			},
			'force': {
				'description': 'overwrite if already published with the same version',
				'optional': true,
				'type': 'body',
				'name': 'force'
			},
			'subtype': {
				'description': 'the subtype of the component',
				'optional': true,
				'type': 'body',
				'name': 'subtype'
			}
		}
	},
	'search': {
		'method': 'GET',
		'path': '/api/search',
		'description': 'API for searching for components',
		'parameters': {
			'term': {
				'description': 'the search term',
				'optional': false,
				'name': 'term',
				'type': 'path'
			},
			'filter': {
				'description': 'the search term filter',
				'optional': true,
				'name': 'filter',
				'type': 'path'
			}
		},
		'pathParameters': [
			'term',
			'filter'
		]
	},
	'unpublish': {
		'method': 'GET',
		'path': '/api/unpublish',
		'description': 'API for unpublishing a published component',
		'parameters': {
			'type': {
				'description': 'type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'getAccess': {
		'method': 'GET',
		'path': '/api/access',
		'description': 'API for getting component access level',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'setAccess': {
		'method': 'POST',
		'path': '/api/access',
		'description': 'API for setting component access level',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'access': {
				'description': 'the access of the component',
				'type': 'body',
				'optional': false,
				'name': 'access'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'getAppc': {
		'method': 'GET',
		'path': '/api/appc/install',
		'description': 'API for listing the AppC packages',
		'parameters': {
			'version': {
				'description': 'the version of the package',
				'optional': true,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'version'
		]
	},
	'listAppc': {
		'method': 'GET',
		'path': '/api/appc/list',
		'description': 'API for listing the AppC packages'
	},
	'installs': {
		'method': 'GET',
		'path': '/api/install',
		'description': 'API for getting a list of components locations to install',
		'parameters': {
			'components': {
				'description': 'components to install',
				'type': 'body',
				'optional': false,
				'name': 'components'
			},
			'platform': {
				'description':'platform',
				'type':'body',
				'optional': false,
				'name':'platform'
			}
		}
	},
	'install': {
		'method': 'GET',
		'path': '/api/install',
		'description': 'API for installing a specific component',
		'parameters': {
			'token': {
				'description': 'the one-time install token',
				'optional': false,
				'name': 'token',
				'type': 'path'
			}
		},
		'pathParameters': [
			'token'
		]
	},
	'addOrg': {
		'method': 'POST',
		'path': '/api/org',
		'description': 'API for adding an org for a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'org_id': {
				'description': 'the org_id to add',
				'type': 'body',
				'optional': false,
				'name': 'org_id'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'deleteOrg': {
		'method': 'DELETE',
		'path': '/api/org',
		'description': 'API for removing an org from a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'org_id': {
				'description': 'the org_id to remove',
				'type': 'body',
				'optional': false,
				'name': 'org_id'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'getOrg': {
		'method': 'GET',
		'path': '/api/org',
		'description': 'API for getting the orgs for a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'addOwner': {
		'method': 'POST',
		'path': '/api/owner',
		'description': 'API for adding an owner to a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'user': {
				'description': 'the user to add',
				'type': 'body',
				'optional': false,
				'name': 'user'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'deleteOwner': {
		'method': 'DELETE',
		'path': '/api/owner',
		'description': 'API for removing an owner of a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'user': {
				'description': 'the user to remove',
				'type': 'body',
				'optional': false,
				'name': 'user'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'getOwner': {
		'method': 'GET',
		'path': '/api/owner',
		'description': 'API for getting the owners of a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'addUser': {
		'method': 'POST',
		'path': '/api/user',
		'description': 'API for adding a user to a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'user': {
				'description': 'the user to add',
				'type': 'body',
				'optional': false,
				'name': 'user'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'deleteUser': {
		'method': 'DELETE',
		'path': '/api/user',
		'description': 'API for removing a user from a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			},
			'user': {
				'description': 'the user to remove',
				'type': 'body',
				'optional': false,
				'name': 'user'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	},
	'getUser': {
		'method': 'GET',
		'path': '/api/user',
		'description': 'API for getting users of a component',
		'parameters': {
			'type': {
				'description': 'the type of the component',
				'optional': false,
				'name': 'type',
				'type': 'path'
			},
			'name': {
				'description': 'the name of the component',
				'optional': false,
				'name': 'name',
				'type': 'path'
			},
			'version': {
				'description': 'the version of the component',
				'optional': false,
				'name': 'version',
				'type': 'path'
			}
		},
		'pathParameters': [
			'type',
			'name',
			'version'
		]
	}
};

/**
 * Constructor for creating an API endpoint
 * @class
 * @description API endpoint
 */
function API(config, key) {
	if (config && typeof(config) === 'string') {
		key = config;
		config = {};
	}
	if (key in APIs) {
		var obj = APIs[key];
		this._config = config;
		this._path = obj.path;
		var self = this;
		Object.keys(obj).forEach(function (key) {
			self[key] = obj[key];
		});
		if (config.debug) {
			debugEnabled = true;
		}
	} else {
		throw new Error('couldn\'t find API using name ' + key);
	}
}

util.inherits(API, events.EventEmitter);

/**
 * adapter to creating the Request object. subclass to
 * change the options passed to request or to use a different
 * request library implementation
 */
API.prototype.createRequest = function () {
	return request.apply(request, arguments);
};

/**
 * adapter called when receiving the response before processing.
 * subclasses can override to change the behavior of the result
 * before it's processed
 */
API.prototype.handleResult = function (err, resp, body) {
	return {
		error: err,
		response: resp,
		body: body
	};
};

/**
 * used internally to debug log
 * a few bites of code borrowed from npm debug library @ https://github.com/visionmedia/debug
 */
function debug() {
	if (!debugEnabled) {
		return;
	}
	var args = Array.prototype.slice.call(arguments);
	if (useColors) {
		var msg = '\u001b[91marrow:sdk\u001b[0m ';
		process.stderr.write(msg);
	}
	if (typeof args[0] !== 'string') {
		// anything else let's inspect with %o
		args = [ '%o' ].concat(args);
	}
	var index = 0;
	args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
		if (match === '%%') {
			return match;
		}
		index++;
		if (format === 'o') {
			match = util.inspect(args[index], { colors:useColors, depth:null });
			args.splice(index, 1);
			index--;
		}
		return match;
	});
	process.stderr.write(util.format.apply(util.format, args));
	process.stderr.write('\n');
}

/**
 * set the request body
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.body = function (data) {
	this._body = data;
	return this;
};

/**
 * set the request body as JSON
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.json = function (data) {
	this._json = data;
	return this;
};

/**
 * set the request path parameters as JSON key/values
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.params = function (data) {
	this._params = data;
	return this;
};

/**
 * set the request query parameters
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.query = function (data) {
	this._query = data;
	return this;
};

/**
 * set a request header
 *
 * @param {string} name header name
 * @param {string} value header value
 */
API.prototype.header = function (name, value) {
	this._headers = this._headers || {};
	this._headers[name] = value;
	return this;
};

/**
 * send the request
 *
 * @param {Object} data optional data to pass as JSON
 * @param {Function} callback optional function to invoke on response
 */
API.prototype.send = function (data, callback) {

	if (data && typeof(data) === 'function') {
		callback = data;
		data = null;
	}

	if (data && typeof(data) === 'object') {
		this._json(data);
	}

	var self = this,
		path = this._path,
		error,
		errorRaised,
		listeners;

	// security model code
	if (API.session) {
		self.header('Authorization', API.session);
	}

	// build any path parameters
	if (this.pathParameters) {
		var values = [];
		for (var c = 0; c < this.pathParameters.length; c++) {
			var name = this.pathParameters[c];
			var param = self.parameters[name];
			var value = self._params && self._params[name] || self._json && self._json[name] || self._body && self._body[name];
			if (!value && !param.optional) {
				error = new Error('missing required path parameter \'' + name + '\'');
				error.code = 'com.appcelerator.arrow.missing.path.parameter';
				error.parameter = name;
				listeners = self.listeners('error');
				// if we have at least one error listener, emit an event
				if (listeners && listeners.length) {
					return this.emit('error', error);
				}
				// we don't have an event listener, throw an Error instead
				throw error;
			} else if (value) {
				// remove them so they don't get added again since they are path parameters
				if (self._json) {
					delete self._json[name];
				}
				if (self._body) {
					delete self._body[name];
				}
				if (self._params) {
					delete self._params[name];
				}
			} else if (!value && param.optional) {
				break;
			}
			values.push(value);
		}
		// append our path parameter values
		path += '/' + values.map(function (value) {
			return encodeURIComponent(value || '');
		}).join('/');
	}

	// append any query parameters
	if (this._query && Object.keys(this._query).length) {
		path += '?' + querystring.stringify(this._query);
	}

	// make sure our base url was set
	var baseurl = this._config && this._config.baseurl || this.baseurl || API.baseurl;
	if (!baseurl) {
		error = new Error('baseurl not set.');
		error.code = 'com.appcelerator.arrow.baseurl.missing';
		listeners = this.listeners('error');
		// if we have at least one error listener, emit an event
		if (listeners && listeners.length) {
			return this.emit('error', error);
		}
		// we don't have an event listener, throw an Error instead
		throw error;
	}

	var url = urllib.resolve(baseurl, path),
		opts = {
			url: url,
			method: this.method,
			json: this._json,
			followAllRedirects: true,
			headers: {
				'Accept': 'application/json',
				'User-Agent': UserAgent
			}
		};

	if (process.env.APPC_CONFIG_PROXY && process.env.APPC_CONFIG_PROXY !== 'undefined') {
		opts.proxy = process.env.APPC_CONFIG_PROXY;
	}

	if (process.env.APPC_CONFIG_CAFILE) {
		opts.ca = fs.readFileSync(process.env.APPC_CONFIG_CAFILE, 'utf8');
	}

	if (process.env.APPC_CONFIG_STRICTSSL === 'false') {
		opts.strictSSL = false;
	}

	// set any headers specified
	if (this._headers) {
		Object.keys(this._headers).forEach(function (key) {
			opts.headers[key] = self._headers[key];
		});
	}

	// do a first pass to determine if we can send as JSON or if we
	// need to send a multipart
	if (this._body && typeof(this._body) === 'object' && !this._json) {
		var multipart = false,
			keys = Object.keys(this._body);
		for (var i = 0; i < keys.length; i++) {
			var bodyValue = this._body[keys[i]],
				bodyType = typeof(bodyValue);
			if (bodyType === 'object' && (bodyValue instanceof Buffer || bodyValue instanceof stream)) {
				multipart = true;
				break;
			}
		}
		if (!multipart) {
			opts.json = this._body;
			this._body = null;
		}
	}

	debug('sending request to %s', url);

	try {
		// create the request
		var req = this.createRequest(opts, function (err, resp, body) {

			var result = self.handleResult(err, resp, body);
			if (!result || typeof(result) !== 'object') {
				throw new Error('handleResult subclass didn\'t properly return the right result');
			}

			// handle transform
			err = result.error;
			resp = result.response;
			body = result.body;

			debug('response received err=%o, body=%o, status code=%d', err, body, resp && resp.statusCode);

			if (err) {
				error = err;
				error.code = 'com.appcelerator.arrow.error';
			}

			if (!error && body && typeof(body) === 'string' && resp.headers && resp.headers['content-type'].indexOf('/json') > 0) {
				try {
					body = JSON.parse(body);
				}
				catch(E) {
					error = E;
					error.code = 'com.appcelerator.arrow.error.json';
					return self.emit('error', error);
				}
			}

			if (!error && resp.statusCode > 399) {
				var http = require('http');
				error = new Error(http.STATUS_CODES[resp.statusCode]);
				error.code = 'com.appcelerator.arrow.http.status.' + resp.statusCode;
			}

			// check to see if...
			if (body && !body.success) {
				// ... it failed
				error = new Error(body.message || body);
				error.code = body.code;
			} else if (body && body.success) {
				// ... it succeeded
				body = body[body.key];
			}

			// if specifying a callback...
			if (callback) {
				// ... just invoke it directly
				if (error) {
					errorRaised = true;
				}
				callback(error, resp, body); // eslint-disable-line callback-return
			} else if (error) {
				// ... otherwise, emit the appropriate event
				debug(error);
				errorRaised = true;
				self.emit('error', error);
			} else {
				self.emit('response', resp, body);
			}
		});

		// handle error
		req.on('error', function (err) {
			if (!errorRaised) {
				errorRaised = true;
				error = err;
				error.code = 'com.appcelerator.arrow.error';
				debug(error);
				self.emit('error', error);
			}
		});

		// handle timeout
		req.on('timeout', function () {
			if (!errorRaised) {
				errorRaised = true;
				error = new Error('timed out');
				error.code = 'com.appcelerator.arrow.timeout';
				debug(error);
				self.emit('error', error);
			}
		});

		// append any body parameters
		if (this._body && typeof(this._body) === 'object') {
			var form = req.form();
			Object.keys(this._body).forEach(function (name) {
				var bodyValue = self._body[name],
					bodyType = typeof(bodyValue);
				if (bodyType === 'object') {
					// check to see if this is a buffer
					if (bodyValue instanceof Buffer) {
						var bufferStream = new stream.Transform();
						bufferStream.push(bodyValue);
						form.append(name, bufferStream);
					} else if (bodyValue instanceof stream) {
						form.append(name, bodyValue);
					} else {
						form.append(name, JSON.stringify(bodyValue));
					}
				} else {
					form.append(name, String(bodyValue));
				}
			});
		}
		return req;
	}
	catch(E) {
		if (!errorRaised) {
			errorRaised = true;
			listeners = self.listeners('error');
			// if we have at least one error listener, emit an event
			if (listeners && listeners.length) {
				return this.emit('error', E);
			} else if (callback) {
				return callback(E);
			}
			throw E;
		}
	}
};

/**
 * enable debug logging
 */
Object.defineProperty(API, 'debug', {

	/**
	 * Set the value for debug logging.
	 * @param value
	 */
	set: function (value) {
		debugEnabled = value;
	},

	/**
	 * Gets the value for debug logging.
	 * @returns {boolean}
	 */
	get: function () {
		return debugEnabled;
	}
});

module.exports = API;
